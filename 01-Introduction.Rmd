---
title: "Introduction et Concepts de base"
output:
  html_document:
    css: "theme.css"
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, cache = FALSE}

library(knitr)
library(tidyverse)
library(questionr)

#knitr::opts_chunk$set(cache = TRUE, echo = TRUE, eval=TRUE, echo=TRUE)
```



# Prise en Main

## Comme une calculatrice:

- Vous voyez l’opérateur d’assignation `<-` :

```{r, eval=TRUE, echo=TRUE}
a <- 2+2
b <- 5-7
c <- 4*12
d <- 10/3
e <- 5^2
```

```{r}
a
b
c
d
e
```


```{block, type='infobox'}
- Les noms d'objets peuvent contenir des lettres, des chiffres, les symboles `.` et `_`. 

- Ils ne peuvent pas commencer par un chiffre. Attention, R fait la différence entre minuscules et majuscules dans les noms d'objets, ce qui signifie que `x` et `X` seront deux objets différents, tout comme `resultat` et `Resultat`. 

Conseils:
- Il est préférable d'éviter les majuscules (pour les risques d'erreur) et les caractères accentués (pour des questions d'encodage) dans les noms d'objets. 

- De même, il faut essayer de trouver un équilibre entre clarté du nom (comprendre à quoi sert l'objet, ce qu'il contient) et sa longueur. Par exemple, on préfèrera comme nom d'objet `taille_conj1` à `taille_du_conjoint_numero_1` (trop long) ou à `t1` (pas assez explicite).
```

### Créer de nouvelles variables

```{r}
Resultat <- a + b
```


## Objets simples

Types d'objets:

- Texte
- Facteurs

```{r}

```




### Vecteurs

Imaginons maintenant qu'on a demandé la taille en centimètres de 5 personnes et qu'on souhaite calculer leur taille moyenne. 

On pourrait créer autant d'objets que de tailles et faire l'opération mathématique qui va bien :

```{r}
taille1 <- 156
taille2 <- 164
taille3 <- 197
taille4 <- 147
taille5 <- 173
(taille1 + taille2 + taille3 + taille4 + taille5) / 5
```


Cette manière de faire n'est évidemment pas pratique du tout. On va plutôt stocker l'ensemble de nos tailles dans un seul objet, de type *vecteur*, avec la syntaxe suivante :

```{r}
tailles <- c(156, 164, 197, 147, 173)
```

Si on affiche le contenu de cet objet, on voit qu'il contient bien l'ensemble des tailles saisies :

```{r}
tailles
```

Un *vecteur* dans R est un objet qui peut contenir plusieurs informations du même type, potentiellement en très grand nombre.

L'avantage d'un vecteur est que lorsqu'on lui applique une opération, celle-ci s'applique à toutes les valeurs qu'il contient. Ainsi, si on veut la taille en mètres plutôt qu'en centimètres, on peut faire :

```{r}
tailles_m <- tailles / 100
tailles_m
```












## Data Frames

```{r, echo=TRUE, message=FALSE, eval=TRUE}
df<-data.frame(subject=as.factor(c("Pierre","Anne","Joyce","Peter","Alan","Camille")), age=as.numeric(c(20, 16, 19, 99, 23, 18)), sex=as.factor(c("M","F","F","M",NA,"F")), height=as.numeric(c(172, 181, 165, 168, 177, 178)), speed=as.numeric(c(11.20,3.00,11.50,10.35,10.98,13.05)))
```

Check the data.frame df by simply typing in:

```{r, echo=TRUE}
df
```

The data has 6 rows and 5 columns:
```{r, echo=TRUE}
dim(df)
```

Because the data are not that big you are able to view them entirely in your R studio. However, if you have very big data you may want to view only the first lines:
```{r, echo=TRUE}
head(df, 4)
```

To inspect the structure of the data: 
```{r, echo=TRUE}
str(df)
```

Some basic statistics can be given by the summary command:

```{r, echo=TRUE}
summary(df)
```

### Missing values

To examine if missing values (NA) are in the data:
```{r, echo=TRUE}
is.na(df)
```

If you want the row and column index where NAs occur:
```{r, echo=TRUE}
which(is.na(df), arr.ind=T)
```

### Impossible extreme values
We can use boxplots to see if there are impossible extreme values:

```{r, echo=TRUE}
par(mfrow=c(1,3))
boxplot(df$age, main="Age (yrs)", cex.lab=2.0, cex.axis=2.0, cex.main=1.6, cex=2.0, col="yellow")
boxplot(df$height, main="Height (cm)", cex.lab=2.0, cex.axis=2.0, cex.main=1.6, cex=2.0, col="red")
boxplot(df$speed, main="Speed (ms)", cex.lab=2.0, cex.axis=2.0, cex.main=1.6, cex=2.0, col="orange")
```

### Finding & replacing the extreme values manually

Compute the mean *before* the removal of outliers:

```{r, echo=TRUE}
mean(df$age)
```

Check if there are cases that are older than 40 years:

```{r, echo=TRUE}
df$age>40
```

Replace the case(s) older than 40 with a missing value (NA).

```{r, echo=TRUE}
df$age[df$age>40]<-NA
```

Compute again the mean age, allowing to remove missing values (NAs):
```{r, echo=TRUE}
mean(df$age, na.rm=TRUE)
```

### Inspecting mean age for male and female participants
Mean age for male and female participants. 

```{r, echo=TRUE}
aggregate(age ~ sex, data=df, FUN=mean, na.rm=TRUE)
```

### Inspecting relations between variables

```{r, echo=FALSE, message=FALSE}
df[2,5]<-NA
```


Use a scatterplot to display the relation between age and speed:
```{r, echo=TRUE}
par(mfrow=c(1,1))
plot(speed ~ age, data=df, col="blue", pch=1, cex=1.2)
```

# <span style="color:orange">QUIZ QUESTIONS AND ANSWERS</span>

### Quiz Question I

Replace the outlier of 3.00 ms in the variable *df$speed* with a NA.

**Answer**
There are multiple solutions possible:

```{r, echo=TRUE}
df$speed[df$speed==3.00]<-NA
```

Another solution:

```{r, echo=TRUE}
df[2,5]<-NA
```

To verify that the value was indeed replaced by a NA use the command `is.na`:

```{r, echo=TRUE}
is.na(df$speed)
```

### Quiz Question II

A dataset could erroneously have double records (duplicates). This is bad and should be removed. 

Seeing the current dataset, what would be a way to discover duplicates in the variable *df$subject*?

Check your solution for the following data.frame that contains double data:

```{r, echo=TRUE, message=FALSE, eval=TRUE}
df<-data.frame(subject=as.factor(c("Pierre","Anne","Joyce","Peter","Alan","Camille", "Pierre")), age=as.numeric(c(20, 16, 19, 99, 23, 18, 20)), sex=as.factor(c("M","F","F","M",NA,"F", "M")), height=as.numeric(c(172, 181, 165, 168, 177, 178, 172)), speed=as.numeric(c(11.20,3.00,11.50,10.35,10.98,13.05, 11.20)))
```

**Answer**

A way to inspect for double records is to use the `table` function.

```{r, echo=TRUE, message=FALSE, eval=TRUE}
table(df$subject)
```

But still simpler, using the `summary` function would also display this:

```{r, echo=TRUE, message=FALSE, eval=TRUE}
summary(df)

```



```{r}
library(questionr)
data(hdv2003)
```

